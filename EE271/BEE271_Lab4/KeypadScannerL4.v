
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module KeypadScannerL4(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);

	wire [ 3:0 ] rawKey, debouncedKey;
	wire rawValid, debouncedValid;
	wire [7:0] keypad;
	assign reset = ~KEY[0];
	reg [3:0] outArray [5:0];
	reg [5:0] displayHex = 0;
	reg debouncedValidPrev;
	integer i;
	reg [7:0] divClock = 500;

	
	//Scan keypad for changes
	Scan FourbyFourKeypad(CLOCK_50, {GPIO[25], GPIO[23], GPIO[21], GPIO[19], GPIO[17], GPIO[15], GPIO[13], GPIO[11]} , rawKey, rawValid);
	
	//Assign Hex displays
	SevenSegment Hex0 (outArray[0], HEX0, displayHex[0]);
	SevenSegment Hex1 (outArray[1], HEX1, displayHex[1]);
	SevenSegment Hex2 (outArray[2], HEX2, displayHex[2]);
	SevenSegment Hex3 (outArray[3], HEX3, displayHex[3]);
	SevenSegment Hex4 (outArray[4], HEX4, displayHex[4]);
	SevenSegment Hex5 (outArray[5], HEX5, displayHex[5]);
	
	Debounce(CLOCK_50, rawKey, rawValid, debouncedKey, debouncedValid );
	
	always @ (posedge CLOCK_50)
	begin
		//every 500 clocks
		if (divClock == 0)
			begin
				divClock <= 500;
				if (reset)
				begin
					//set all values to zero.
					displayHex <= 0;
					for (i = 0; i < 6; i = i + 1)
						outArray[i] <= 0;
				end
		else
			begin
				debouncedValidPrev <= debouncedValid;
				if (debouncedValid && ~debouncedValidPrev)
				begin
				//shift the values
					for (i = 5; i > 0; i = i - 1)
						outArray[i] <= outArray[i-1];
					//set the 0 space to the key pressed
					outArray[0] <= debouncedKey;
					displayHex <= {displayHex[4:0], 1'b1};
				end
			end
		end
		else
			divClock <= divClock - 1;
	end
endmodule

module Debounce( input CLOCK_50, input [ 3:0 ] rawKey, input rawValid, output reg[ 3:0 ] debouncedKey, output reg debouncedValid );
   
	parameter countMax = 50000;
	reg [3:0] prevKey;
	reg [31:0] debCount = countMax;
	
	always @(posedge CLOCK_50)
		begin
		if (debouncedValid)
			if (rawValid)
			begin
				//if the key has been constant for 50000 clocks
				//assign debouncedkey to the rawKey value.
				if (debCount == 0)
					debouncedKey <= rawKey;
				//count the number of consistent keys
				else if (rawKey == prevKey)
					debCount <= debCount - 1;
				else
					begin
					//not valid input for 50000 clocks, resets the counter
					debCount <= countMax;
					debouncedValid <= 0;
					end
			end
			else
				begin	
				if (debCount == countMax)
					debouncedValid  <= 0;
				debCount <= debCount + 1;
				end
			
		else
			begin
			prevKey <= rawKey;
			if(!(rawValid & (prevKey == rawKey)))
				debCount <= countMax;
			else	
					if(debCount == 0)	
						debouncedValid <= 1;		
					else 
						debCount <= debCount - 1;
			end
		end
endmodule


module Scan( input CLOCK_50, inout [ 7:0 ] keypad, output reg [ 3:0 ] rawKey, output reg rawValid );

	reg [1:0] selector;
	reg [3:0] columns;
	wire [3:0] rows = keypad[7:4];
	assign keypad[3:0] = columns[3:0];
	
	wire enabled = (&rows);
	
	reg [31:0] clock;
	parameter clockDivisor = 500;
	
	always @( posedge CLOCK_50 )
	begin
		if ( clock == 0 )
		begin
			clock <= clockDivisor; 
			if(enabled)
			begin
				selector <= selector + 1;
				case (selector)
					0: columns[3:0] <= 4'b0zzz;
					1: columns[3:0] <= 4'bz0zz;
					2: columns[3:0] <= 4'bzz0z;
					3: columns[3:0] <= 4'bzzz0;
				endcase
			end
		end
		else	
			clock <= clock - 1;
	end
	always @(*)
	begin			
		rawValid = ~enabled;
		casex( {rows, columns} )
				8'b0111_0xxx: rawKey[3:0] = 4'h1;//b0001; //1
				8'b0111_x0xx: rawKey[3:0] = 4'h2;//b0010; //2
				8'b0111_xx0x: rawKey[3:0] = 4'h3;//b0011; //3
				8'b0111_xxx0: rawKey[3:0] = 4'hA;//b1010; //A
				
				8'b1011_0xxx: rawKey[3:0] = 4'h4;//b0100; //4
				8'b1011_x0xx: rawKey[3:0] = 4'h5;//b0101; //5
				8'b1011_xx0x: rawKey[3:0] = 4'h6;//b0110; //6
				8'b1011_xxx0: rawKey[3:0] = 4'hB;//b1011; //B
				
				8'b1101_0xxx: rawKey[3:0] = 4'h7;//b0111; //7
				8'b1101_x0xx: rawKey[3:0] = 4'h8;//b1000; //8
				8'b1101_xx0x: rawKey[3:0] = 4'h9;//b1001; //9
				8'b1101_xxx0: rawKey[3:0] = 4'hC;//b1100; //C
				
				8'b1110_0xxx: rawKey[3:0] = 4'hE;//b1110; //E
				8'b1110_x0xx: rawKey[3:0] = 4'h0;//b0000; //0
				8'b1110_xx0x: rawKey[3:0] = 4'hF;//b1111; //F
				8'b1110_xxx0: rawKey[3:0] = 4'hD;//b1101; //D
			endcase
	end
endmodule


module SevenSegment( input [3:0] hexDigit, output [6:0] segments, input active );

	wire b0, b1, b2, b3;
	wire [6:0] s;
     
	assign b0 = hexDigit[0];    
	assign b1 = hexDigit[1];    
	assign b2 = hexDigit[2];    
	assign b3 = hexDigit[3];   
	
	assign s[0] = (b1 & b2 | ~b1 & ~b2 & b3 | ~b0 & b3 | ~b0 & ~b2 | b0 & b2 & ~b3 | b1 & ~b3) & active;  
	assign s[1] = (~b3 & ~b2 | ~b3 & ~b1 & ~b0 | ~b3 & b1 & b0 | ~b2 & b1 & ~b0 | b3 & ~b1 & b0 | b3 & ~b2 & ~b1) & active;
	assign s[2] = (b3 & ~b2 | ~b3 & b2 | ~b1 & b0 | ~b3 & ~b1 | ~b3 & b0) & active;
	assign s[3] = (b3 & ~b1 | b2 & ~b1 & b0 | b3 & ~b2 & b0 | b2 & b1 & ~b0 | ~b3 & ~b2 & b1 | ~b3 & ~b2 & ~b0) & active;
	assign s[4] = (~b2 & ~b0 | b3 & b2 | b1 & ~b0 | b3 & b1 & b0) & active;
	assign s[5] = (~b1 & ~b0 | ~b3 & b2 & ~b1 | b3 & b1 | b2 & b1 & ~b0 | b3 & ~b2) & active;
	assign s[6] = (~b3 & ~b2 & b1 | b1 & ~b0 | b3 & b0 | ~b3 & b2 & ~b1 | b3 & ~b2 & ~b1) & active;
	
	assign segments = ~s;           
	
endmodule