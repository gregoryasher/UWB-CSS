
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module AddingMachine(

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);
	//We know of the following implementation but do not prefer
	//this method stylistically.
	/*
	wire [4:0] A, B;
	wire [5:0] C;
	assign A = SW[9:5];
	assign B = SW[4:0];
	assign C = A + B;
	*/
	//We stuck with our implementation because we believe it
	// has better readability
		
	//assign the switches to toggle the indicator LEDâ€™s
	assign LEDR = SW;
	
	//Declaration of SUM to hold the addition of the two inputs.
	// 8 bits long
	wire [7:0] SUM;
	assign SUM = SW[4:0] + SW[9:5];
	//after addition is completed, use SevenSegment to determine how to 
	//print the output
	
	//Use the SevenSegment module to display the switch inputs correctly
	//SevenSegment has usage:  (input_array , HEX_Display , active)
	SevenSegment Hex0( SUM[3:0] , HEX0, 1);
	SevenSegment Hex1( SUM[7:4] , HEX1, |SUM[7:4] );
	SevenSegment Hex2( SW[3:0], HEX2, 1 );
	SevenSegment Hex3( SW[4], HEX3, SW[4]);
	SevenSegment Hex4( SW[8:5], HEX4, 1 );
	SevenSegment Hex5( SW[9], HEX5, SW[9]);
	


endmodule

//This module was provided incomplete in "BEE 271 Lab 2 Adding machine.pdf"
//Our responsibility was to use truth tables and karnaugh maps to
//determine the logic for each of the segments for the screens.
//SevenSegment has usage:  (input_array , HEX_Display , active)
module SevenSegment( input [3:0] hexDigit, output [6:0] segments, input active );

	wire b0, b1, b2, b3;
	wire [6:0] s;
     
	assign b0 = hexDigit[0];    
	assign b1 = hexDigit[1];    
	assign b2 = hexDigit[2];    
	assign b3 = hexDigit[3];   
	
	assign s[0] = (b1 & b2 | ~b1 & ~b2 & b3 | ~b0 & b3 | ~b0 & ~b2 | b0 & b2 & ~b3 | b1 & ~b3) & active;  
	assign s[1] = (~b3 & ~b2 | ~b3 & ~b1 & ~b0 | ~b3 & b1 & b0 | ~b2 & b1 & ~b0 | b3 & ~b1 & b0 | b3 & ~b2 & ~b1) & active;
	assign s[2] = (b3 & ~b2 | ~b3 & b2 | ~b1 & b0 | ~b3 & ~b1 | ~b3 & b0) & active;
	assign s[3] = (b3 & ~b1 | b2 & ~b1 & b0 | b3 & ~b2 & b0 | b2 & b1 & ~b0 | ~b3 & ~b2 & b1 | ~b3 & ~b2 & ~b0) & active;
	assign s[4] = (~b2 & ~b0 | b3 & b2 | b1 & ~b0 | b3 & b1 & b0) & active;
	assign s[5] = (~b1 & ~b0 | ~b3 & b2 & ~b1 | b3 & b1 | b2 & b1 & ~b0 | b3 & ~b2) & active;
	assign s[6] = (~b3 & ~b2 & b1 | b1 & ~b0 | b3 & b0 | ~b3 & b2 & ~b1 | b3 & ~b2 & ~b1) & active;
	
	assign segments = ~s;           
	
endmodule
